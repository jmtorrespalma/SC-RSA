/*  Copyright (C) 2015 Juan Manuel Torres Palma <j.m.torrespalma@gmail.com>
    This file is part of the SC-RSA program.

    SC-RSA is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    SC-RSA is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with SC-RSA.  If not, see <http://www.gnu.org/licenses/>.  */

/*  This program encrypts a given plain text file (ASCII only) using a public
 *  key, that if not specified in options, takes key.pub as default. The
 *  algorithm used is RSA-32, a very simple and basic one only for academic
 *  purposes. Do not use this program for other purposes as it is easily
 *  breakable. */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <math.h>

/* Max size of messages. */
#define SZ 256

/* Parse command line arguments.
 * The -k option is used to specify a public key file. Default
 * name of the file is "key.pub", that is the one generated by
 * the key generator. */
#define parse_args()						\
	do {							\
		char const *opts = "k:";			\
		int c;						\
								\
		while ((c = getopt (argc, argv, opts)) != -1)	\
			if (c == 'k')				\
				keyfile = optarg;		\
		/* Checks if message argument is added. */	\
		if (optind < argc)				\
			message_file = argv[optind];		\
	} while (0)

/* Read public or private key, depending on which parameters we pass
 * to the function.
 * To read public key, call read_key(key_file, n, e)
 * To read private key, call read_key(key_file, n, d) */
void read_key(char *const key_file, uint32_t * n, uint32_t * e_or_d)
{
	FILE *fd;

	if (! !(fd = fopen(key_file, "r"))) {
		fscanf(fd, "%u, %u\n", n, e_or_d);
		fclose(fd);
	} else {

		fprintf(stderr, "Error: file %s not found.\n", key_file);
		exit(EXIT_FAILURE);
	}

}

/* Read message encrypted or in plain text to store it in
 * another array ready to be treated and modified. */
void read_msg(char *const msg_file, char *const msg)
{
	FILE *fd;
	char file_f;
	char c;
	unsigned cntr = 0;

	/* Is there a file? */
	file_f = (msg_file != NULL);

	/* If no file specified, read from stdin. */
	if (!file_f)
		fd = stdin;

	else {			/* Open file. */
		if (!(fd = fopen(msg_file, "r"))) {
			fprintf(stderr, "Error: file %s not found.\n",
				msg_file);
			exit(EXIT_FAILURE);
		}
	}

	/* Copy char by char. */
	while ((c = fgetc(fd)) != EOF && cntr < SZ - 1)
		msg[cntr++] = c;
	/* Add string terminator. */
	msg[cntr] = '\0';

	if (!file_f)
		fclose(fd);

}

/* Encrypts a message using RSA-32.
 * Stores the encrypted message in enc_msg, using key (n, e).
 * We will encrypt char by char (m=0-255), even if it's not recommended
 * but it's the easiest way to achieve encryption. Returns the number
 * ef encrypted items. */
int encrypt(char *msg, uint32_t * enc_msg, uint32_t n, uint32_t e)
{
	/* No risk of overflow, e = 3. */
	int i;

	for (i = 0; i < SZ - 1 && msg[i] != '\0'; ++i)
		enc_msg[i] = ((uint32_t) pow(msg[i], e)) % n;

	return i;
}

/* Prints the encrypted message to the screen. */
#define print_msg(enc_msg, size)			\
	do {						\
		int ii;					\
							\
		/* FIXME: This printf portable? */	\
		for (ii = 0; ii < size; ++ii)		\
			printf("%08x", enc_msg[ii]);	\
		putchar('\n');				\
	} while (0)

/* Performs RSA-32 encryption from a given file and prints it out to the
 * standard output. */
int main(int argc, char *argv[])
{

	char *keyfile = "key.pub";
	char *message_file = NULL;	/* File to encrypt */
	char msg[SZ];
	uint32_t enc_msg[SZ];	/* Message after encrypting it */

	uint32_t n, e, max;

	parse_args();

	read_key(keyfile, &n, &e);
	read_msg(message_file, msg);

	max = encrypt(msg, enc_msg, n, e);

	print_msg(enc_msg, max);

	return 0;
}
